package main

import (
	"fmt"
	"os"
	"strings"

	"github.com/iferdel/chile-economic-indexes-cli/internal/spinner"
	"github.com/peterh/liner"
)

func CLI(cfg *config) {

	cfg.CLILiner = liner.NewLiner()

	// Load history file if exists
	cmdHistoryFile := ".cmd_history"
	if f, err := os.Open(cmdHistoryFile); err == nil {
		_, err := cfg.CLILiner.ReadHistory(f)
		if err != nil {
			fmt.Printf("error while loading cmd history file: %v\n", err)
		}
		err = f.Close()
		if err != nil {
			fmt.Printf("error while closing cmd history file: %v\n", err)
		}
	}

	// persistent credentials from last session by autogenerated localfile
	err := loadLocalCredentials(cfg, bcchCredentials)
	if err != nil {
		fmt.Println(err)
	}

	if user := cfg.bcchapiClient.AuthConfig.User; user == "" {
		fmt.Println("You havent set any credentials. Start with 'set-credentials' command.")
	} else {
		fmt.Printf("Connected as %q\n", user)
	}

	// Save history to file on exit -- Create creates or truncates
	defer func() {
		if f, err := os.Create(cmdHistoryFile); err == nil {
			_, err := cfg.CLILiner.WriteHistory(f)
			if err != nil {
				fmt.Printf("error while updating/saving cmd history file: %v\n", err)
			}
			err = f.Close()
			if err != nil {
				fmt.Printf("error while closing cmd history file: %v\n", err)
			}
		}
		err := cfg.CLILiner.Close()
		if err != nil {
			fmt.Printf("error while closing CLI tool: %v\n", err)
		}
	}()

	cfg.CLILiner.SetCtrlCAborts(true)

	for {
		userInput, err := cfg.CLILiner.Prompt("bcch >")
		if err != nil {
			if err == liner.ErrPromptAborted {
				break
			}
			fmt.Println("Error reading line:", err)
			continue
		}
		// add command to history
		cfg.CLILiner.AppendHistory(userInput)

		cleanedInput := cleanInput(userInput)

		if len(cleanedInput) == 0 {
			continue
		}

		commandName := cleanedInput[0]
		command, ok := cfg.getCommands()[commandName]

		if !ok {
			fmt.Println("Command not available, see 'help'")
			continue
		}

		args := []string{}
		if len(cleanedInput) > 1 {
			args = cleanedInput[1:]
		}

		err = command.callback(cfg, args...)
		if err != nil {
			if err == errExit {
				break
			}
			fmt.Println(err)
			continue
		}
	}
}

func cleanInput(input string) []string {
	words := strings.Fields(input)
	return words
}

type cliCommand struct {
	name        string
	description string
	callback    func(*config, ...string) error
}

func (cfg *config) getCommands() map[string]cliCommand {
	return map[string]cliCommand{
		"help": {
			name:        "help",
			description: "This is the help of the cli tool",
			callback:    commandHelp,
		},
		"exit": {
			name:        "exit",
			description: "exits the cli tool",
			callback:    commandExit,
		},
		"set-credentials": {
			name:        "set-credentials",
			description: "set credentials to requests to the BCCH",
			callback:    commandSetCredentials,
		},
		"search": {
			name: "search",
			description: `it shows the available series to fetch based on a frequency: DAILY, MONTHLY, QUARTERLY o ANNUAL. 
            -keyword flag helps to filter over the series, you just need to add the work to be looked at in the series 
            -rg flag allows to use ripgrep to control the filtering (you may need to install rg on your computer)`,
			callback: withSpinnerWrapper(cfg.spinner, commandSearchSeries),
		},
		"get": {
			name:        "get",
			description: "get dated values from specific series",
			callback:    withSpinnerWrapper(cfg.spinner, commandGetSeriesData),
		},
	}
}

func withSpinnerWrapper(s *spinner.Spinner, fn func(*config, ...string) error) func(*config, ...string) error {
	return func(cfg *config, args ...string) error {
		s.Start()
		defer s.Stop()
		return fn(cfg, args...)
	}
}
